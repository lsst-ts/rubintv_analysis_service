# This file is part of lsst_rubintv_analysis_service.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import json
import logging
import traceback
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .data import DataCenter


logger = logging.getLogger("lsst.rubintv.analysis.service.command")


def construct_error_message(error_name: str, description: str, traceback: str) -> str:
    """Use a standard format for all error messages.

    Parameters
    ----------
    error_name :
        Name of the error.
    description :
        Description of the error.

    Returns
    -------
    result :
        JSON formatted string.
    """
    return json.dumps(
        {
            "type": "error",
            "content": {
                "error": error_name,
                "description": description,
                "traceback": traceback,
            },
        }
    )


def error_msg(error: Exception, traceback: str) -> str:
    """Handle errors received while parsing or executing a command.

    Parameters
    ----------
    error :
        The error that was raised while parsing, executing,
        or responding to a command.

    Returns
    -------
    response :
        The JSON formatted error message sent to the user.

    """
    if isinstance(error, json.decoder.JSONDecodeError):
        return construct_error_message("JSON decoder error", error.args[0], traceback)

    if isinstance(error, CommandParsingError):
        return construct_error_message("parsing error", error.args[0], traceback)

    if isinstance(error, CommandExecutionError):
        return construct_error_message("execution error", error.args[0], traceback)

    if isinstance(error, CommandResponseError):
        return construct_error_message("command response error", error.args[0], traceback)

    # We should always receive one of the above errors, so the code should
    # never get to here. But we generate this response just in case something
    # very unexpected happens, or (more likely) the code is altered in such a
    # way that this line is it.
    msg = "An unknown error occurred, you should never reach this message."
    return construct_error_message(error.__class__.__name__, msg, traceback)


class CommandParsingError(Exception):
    """An `~Exception` caused by an error in parsing a command and
    constructing a response.
    """

    pass


class CommandExecutionError(Exception):
    """An error occurred while executing a command."""

    pass


class CommandResponseError(Exception):
    """An error occurred while converting a command result to JSON"""

    pass


@dataclass(kw_only=True)
class BaseCommand(ABC):
    """Base class for commands.

    Attributes
    ----------
    result :
        The response generated by the command as a `dict` that can
        be converted into JSON.
    response_type :
        The type of response that this command sends to the user.
        This should be unique for each command.
    """

    command_registry = {}
    result: dict | None = None
    response_type: str

    @abstractmethod
    def build_contents(self, data_center: DataCenter) -> dict:
        """Build the contents of the command.

        Parameters
        ----------
        data_center :
            Connections to databases, the Butler, and the EFD.

        Returns
        -------
        contents :
            The contents of the response to the user.
        """
        pass

    def execute(self, data_center: DataCenter):
        """Execute the command.

        This method does not return anything, buts sets the `result`,
        the JSON formatted string that is sent to the user.

        Parameters
        ----------
        data_center :
            Connections to databases, the Butler, and the EFD.

        """
        self.result = {"type": self.response_type, "content": self.build_contents(data_center)}

    def to_json(self, request_id: str | None = None):
        """Convert the `result` into JSON."""
        if self.result is None:
            raise CommandExecutionError(f"Null result for command {self.__class__.__name__}")
        if request_id is not None:
            self.result["requestId"] = request_id
        return json.dumps(self.result)

    @classmethod
    def register(cls, name: str):
        """Register a command."""
        BaseCommand.command_registry[name] = cls


def execute_command(command_str: str, data_center: DataCenter) -> str:
    """Parse a JSON formatted string into a command and execute it.

    Command format:
    ```
    {
        name: command name,
        content: command content (usually a dict)
    }
    ```

    Parameters
    ----------
    command_str :
        The JSON formatted command received from the user.
    data_center :
        Connections to databases, the Butler, and the EFD.
    """
    logger.info(f"Received command {command_str}")
    try:
        command_dict = json.loads(command_str)
        if "type" in command_dict and command_dict["type"] == "ping":
            return json.dumps({"type": "pong"})
        if not isinstance(command_dict, dict):
            raise CommandParsingError(f"Could not generate a valid command from {command_str}")
    except Exception as err:
        logging.exception("Error converting command to JSON.")
        traceback_string = traceback.format_exc()
        return error_msg(err, traceback_string)

    try:
        logger.info(f"Parsing command {command_dict}")
        if "name" not in command_dict.keys():
            raise CommandParsingError("No command 'name' given")

        if command_dict["name"] not in BaseCommand.command_registry.keys():
            raise CommandParsingError(f"Unrecognized command '{command_dict['name']}'")

        parameters = command_dict.get("parameters", {})
        command = BaseCommand.command_registry[command_dict["name"]](**parameters)

    except Exception as err:
        logging.exception(f"Error parsing command {command_dict}")
        traceback_string = traceback.format_exc()
        return error_msg(CommandParsingError(f"'{err}' error while parsing command"), traceback_string)

    try:
        logger.info(f"Executing command {command_str}")
        command.execute(data_center)
    except Exception as err:
        logging.exception(f"Error executing command {command_dict}")
        traceback_string = traceback.format_exc()
        return error_msg(CommandExecutionError(f"{err} error executing command."), traceback_string)

    try:
        if "requestId" in command_dict:
            result = command.to_json(command_dict["requestId"])
        else:
            result = command.to_json()
    except Exception as err:
        logging.exception("Error converting command response to JSON.")
        traceback_string = traceback.format_exc()
        return error_msg(
            CommandResponseError(f"{err} error converting command response to JSON."), traceback_string
        )

    return result
